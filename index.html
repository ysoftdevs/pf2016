<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>PF 2016</title>
	<meta name="author" content="Juraj MichÃ¡lek" />
	<meta name="description" content="PF 2016 greeting - puzzle game - set direction for ball" />
	
	<script src="js/kiwi-js-v1.4.0/kiwi.js"></script>
	<script src="js/app/level-selector.js"></script>
</head>
<body>

<script>
var state = new Kiwi.State('state');

state.preload = function() {
	this.addJSON('tilemap', 'tilemap.json');
	this.addSpriteSheet('base', './data/images/gfx64/tiles.png', 64, 64);
    this.addSpriteSheet('character', './data/images/gfx64/marble_black.png', 80, 80 );
	this.addSpriteSheet('oneWay', './data/images/gfx64/st_oneway.png', 64, 64 );
	this.addSpriteSheet('finishMarker', './data/images/gfx64/finish_marker.png', 64, 64 );
	this.addSpriteSheet('button', './data/images/gfx64/button.png', 128, 64 );
}

state.velocityX = 64;
state.velocityY = 64;

state.create = function() {

	this.tilemap = new Kiwi.GameObjects.Tilemap.TileMap(this, 'tilemap', this.textures.base);

    this.character = new Kiwi.GameObjects.Sprite(this, this.textures.character, 2*64 - 8, 64 - 8);
	// Hitbox is detecting collision in future step.
	// This is little bit counter intuitive. 
	// You have to make collision box smaller at least one step.	
    this.character.box.hitbox = new Kiwi.Geom.Rectangle( 12, 12, 58, 58 );
	this.character.physics = this.character.components.add( new Kiwi.Components.ArcadePhysics( this.character, this.character.box ) );
	this.character.physics.acceleration.y = 0;
	this.character.physics.maxVelocity.y = 140;

    this.character.animation.add('walking', [ 0, 1 ], 0.2, true);
	this.character.animation.add('idle', [ 2, 3, 4, 5, 4, 3 ], 0.2, true);

    var redirector = new Kiwi.GameObjects.Sprite(this, this.textures.oneWay, 9*64, 2*64);	
	redirector.affectVelocityX = this.velocityX;
	redirector.affectVelocityY = 0;
	redirector.input.enableDrag(true);	
	redirector.input.onDragStarted.add(this.startedDrag, this);
	redirector.input.onDragStopped.add(this.stoppedDrag, this );
	
	var redirector2 = new Kiwi.GameObjects.Sprite(this, this.textures.oneWay, 9*64, 3*64);	
	redirector2.affectVelocityX = 0;
	redirector2.affectVelocityY = this.velocityY;
	redirector2.cellIndex = 6;
	redirector2.input.enableDrag(true);
	redirector2.input.onDragStarted.add(this.startedDrag, this);
	redirector2.input.onDragStopped.add(this.stoppedDrag, this );
	
	this.finishMarker = new Kiwi.GameObjects.Sprite(this, this.textures.finishMarker, 6*64, 4*64);	
	this.finishMarker.animation.add('idle', [ 0, 1, 2, 3, 2, 1 ], 0.3, true);
	this.finishMarker.animation.play('idle', true);
	
	this.redirectorGroup = new Kiwi.Group( this );
	this.redirectorGroup.addChild(redirector);
	this.redirectorGroup.addChild(redirector2);

    // Ground layer
    this.addChild(this.tilemap.layers[0]);

    this.addChild(this.character);

    // Walls layer
    this.addChild(this.tilemap.layers[1]);
	this.addChild(this.finishMarker);
	
	// Add action objects
	this.addChild(this.redirectorGroup);
	
	// Sky layer
    this.addChild(this.tilemap.layers[2]);
    
    
    for(var i = 21; i < this.tilemap.tileTypes.length; i++) {
		this.tilemap.tileTypes[i].allowCollisions = Kiwi.Components.ArcadePhysics.ANY;
	}
    
	this.keyboard = this.game.input.keyboard;

	this.leftKey = this.keyboard.addKey(Kiwi.Input.Keycodes.LEFT, true);
	this.rightKey = this.keyboard.addKey(Kiwi.Input.Keycodes.RIGHT, true);
    //Prevent the down key from scrolling the page
	this.keyboard.addKey(Kiwi.Input.Keycodes.DOWN, true);
    
    this.stageState = 'init';
	
	this.myButton = new Kiwi.GameObjects.Textfield( this, "Start", 9*64+16, 60, "#000", 32, 'normal', 'Impact' );
	this.sprite = new Kiwi.GameObjects.Sprite(this, this.textures.button, 9*64, 50);
	this.sprite.input.onUp.add( this.buttonReleased, this );	
	this.character.input.onUp.add( this.buttonReleased, this );
	this.addChild( this.sprite );
	this.addChild( this.myButton );
}

state.buttonReleased = function(sprite) {	
	if (this.stageState == 'init') {
		this.myButton.text = '...';	
		this.activateScene();
	} else if (this.stageState == 'stop') {
		this.resetCharacter();
		this.myButton.text = 'Start'
		this.stageState = 'init';
	} else if (this.stageState == 'complete') {
		game.states.switchState('levelSelector');
	}
}

state.resetCharacter = function () {
    this.character.physics.velocity.x = 0;
    this.character.physics.velocity.y = 0;
    this.character.x = 2*64 - 8;
    this.character.y = 64 - 8;
}

state.startedDrag = function(sprite) {
	sprite.formerX = sprite.x;
	sprite.formerY = sprite.y;	 
}

/**
 * Reverse effect of drag operaion. Set original coordinates.
 */
state.resetDrag = function(sprite) {
	sprite.x = sprite.formerX;
	sprite.y = sprite.formerY;
}

/**
 * Perform adjustments of coordinates for drop operation.
 * Make sure that object is dropped on valid place and check
 * collision with other objects. In case of failure revert
 * to former coordinates.
 */
state.stoppedDrag = function(sprite) {
	if (sprite.x % 64 > 32) {
		sprite.x += 64;
	}
	if (sprite.y % 64 > 32) {
		sprite.y += 64;
	}
	sprite.x = sprite.x - sprite.x % 64;
	sprite.y = sprite.y - sprite.y % 64;
	
	// Make sure that we drop tile only on valid ground
	var tile = this.tilemap.layers[0].getTileFromXY(sprite.x / 64 , sprite.y /64);
	if ((tile.index == 0) || (tile == null)) {
		this.resetDrag(sprite);
	} else {
		// Make sure that we are not dropping on another redirector object
		var redirectors = this.redirectorGroup.members;
		for ( var i = 0; i < redirectors.length; i++ ) {
			var redirector = redirectors[i];
			
			// Skip comparision of self
			if (sprite === redirector) {
				continue;
			}
			
			if ((sprite.x == redirector.x) && (sprite.y == redirector.y)) {
				this.resetDrag(sprite);
				break;
			}
		}
	}
}

state.activateScene = function () {
    this.character.physics.velocity.y = this.velocityY;
	this.stageState = 'running';
}

state.update = function () {
	//Update all the gameobjects
	Kiwi.State.prototype.update.call(this);

	//Update physics
	this.checkCollision();

	this.updateCharacterMovement();
	this.updateCharacterAnimation();
	
	// this.resetCharacter();
}

state.updateCharacterAnimation = function () {
    
    if(( this.character.physics.velocity.y != 0 ) || (this.character.physics.velocity.x != 0)) {
        this.character.animation.play('walking', false);
    } else {
        this.character.animation.play('idle', false);
    }
}

//Resolve collisions between the character and the first layer. 
state.checkCollision = function () {
	this.tilemap.layers[1].physics.overlapsTiles( this.character, true );

	
	if ((this.character.physics.velocity.x == 0) && (this.character.physics.velocity.y == 0)) {
		if (this.stageState == 'running') {
			this.stageState = 'stop';
			this.myButton.text = 'Restart'
		}
		return;
	}

	// Make collision detection only when ball is fully on the same tile
	var positionX = Math.round(this.character.x) + 8;
	var positionY = Math.round(this.character.y) + 8;
	if ((Math.round(positionX) % 64 != 0) || (Math.round(positionY)% 64 != 0)) {
		return;
	}

	var redirectors = this.redirectorGroup.members;
	for ( var i = 0; i < redirectors.length; i++ ) {
		var redirector = redirectors[i];
		if (((Math.round(positionX/64) == Math.round(redirector.x/64) )) && (Math.round(positionY/64) == Math.round(redirector.y/64))) {
			this.character.physics.velocity.x = redirector.affectVelocityX;
			this.character.physics.velocity.y = redirector.affectVelocityY;
			this.character.y = Math.round(this.character.y);
			this.character.x = Math.round(this.character.x);
		}
	} 
		
	if (((Math.round(positionX/64) == Math.round(this.finishMarker.x/64) )) && (Math.round(positionY/64) == Math.round(this.finishMarker.y/64))) {
		this.stageState = 'complete';
		this.myButton.text = 'Next->'
		this.character.physics.velocity.x = 0;
		this.character.physics.velocity.y = 0;
	}

}

state.updateCharacterMovement = function () {
	
	//Move the player/character
	if ( this.leftPressed ) {
		this.character.scaleX = -1;
        this.character.physics.velocity.x = -this.velocityX;

	} else if ( this.rightPressed ) {
		this.character.scaleX = 1;
        this.character.physics.velocity.x = this.velocityY;
	} 

}

var game = new Kiwi.Game(null, 'PF 2016', levelSelectorState);
game.levelIndex = 0;
game.states.addState(state);

</script>

</body>
</html>